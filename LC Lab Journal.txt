Lab Notes!

To start, high level thinking is that we can set up a single, pretty straightforward C program that will do everything we want.  We'll have some parameters to specify at runtime maybe, in order to specify number of machines to simulate, etc.  Then when we boot things up, simply do any sort of initialization necessary, then fork off procs for each machine to simulate.  As we fork off, we can just keep track of pipes to facilitate inter-proc comms, and then have each simulation proc do it's thing and print to a central log.  Lets see how this goes.

So a first thought is after spawning off the correct number of procs (at first 3, then a number set by args), the parent proc will exit, but all the children need to be able to communicate.  The easiest solution might be something to the tune of "int pipefd[2][n]" in the parent, where n is the number of procs to spawn.  Then, upon spawning, each child will immediately close all read ends except it's own (we can preset "n" as a variable in each proc before forking) and then it can write to the write ends as it pleases throughout.  Let see if this bit works.

After reviewing some pipe details, I seem to have the proc spawning initialized and working.  The only problem is debugging is getting cumbersome since it is hard to tell which proc will be able to print to the terminal, so I'm thinking I'll redirect all the procs' and the parent's stderr to some error log file.

(NOTE: Also discovered there is apparently some proc vital to my linux setup called "sim" which was the original name of my program.  This lead to terrible problems.  It is now called lcsim.c)

Alright, all the initialization is set up.  As thing stand, the spawner sets up all the pipes, forks all 3 (or more) procs, and then lets them do their thing.  All the procs handle their own initialization and LC stuff in the lclock() function.  The only thing this does now is set up the log file so that we can easily log once the logical clocks are instantiated.  Now to test the IPC channels quick and then impliment the LC code.

Now that the procs are all set, I'm filling in the lclocks() function.  Things work well it seams, I have a loop at the end that runs while time elapsed since the function began is less than that determined precompile, and on each iteration is sleeps for an interval determined by the simulated clock speed of the proc in particular.  I did run into a bump setting random clock speeds, as the simultaneity of the procs meant I was getting the same random clockspeed, and since all the simulation procs have very similar PIDs, these didn't add muchn entropy, so I moved to generating all 3 clock speeds prior to forking off the simulation procs, and then using them at initialization.

The next challenge was I didn't think ahead about how to get around the fact that pipes block on read if there is nothing in them and the pipe is open, as would happen in the sim, but I found a way to set a NON_BLOCK flag for the pipe fds that should let us determine whether there is a message without blocking.