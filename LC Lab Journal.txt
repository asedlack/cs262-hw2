=================== Lab Notes! ==========================

1.) Building the simulation
	To start, high level thinking is that we can set up a single, pretty straightforward C program that will do everything we want.  We'll have some parameters to specify at runtime maybe, in order to specify number of machines to simulate, etc.  Then when we boot things up, simply do any sort of initialization necessary, then fork off procs for each machine to simulate.  As we fork off, we can just keep track of pipes to facilitate inter-proc comms, and then have each simulation proc do it's thing and print to a central log.  Lets see how this goes.

	So a first thought is after spawning off the correct number of procs (at first 3, then a number set by args), the parent proc will exit, but all the children need to be able to communicate.  The easiest solution might be something to the tune of "int pipefd[2][n]" in the parent, where n is the number of procs to spawn.  Then, upon spawning, each child will immediately close all read ends except it's own (we can preset "n" as a variable in each proc before forking) and then it can write to the write ends as it pleases throughout.  Let see if this bit works.

	After reviewing some pipe details, I seem to have the proc spawning initialized and working.  The only problem is debugging is getting cumbersome since it is hard to tell which proc will be able to print to the terminal, so I'm thinking I'll redirect all the procs' and the parent's stderr to some error log file.

	(NOTE: Also discovered there is apparently some proc vital to my linux setup called "sim" which was the original name of my program.  This lead to terrible problems.  It is now called lcsim.c)

	Alright, all the initialization is set up.  As thing stand, the spawner sets up all the pipes, forks all 3 (or more) procs, and then lets them do their thing.  All the procs handle their own initialization and LC stuff in the lclock() function.  The only thing this does now is set up the log file so that we can easily log once the logical clocks are instantiated.  Now to test the IPC channels quick and then impliment the LC code.

	Now that the procs are all set, I'm filling in the lclocks() function.  Things work well it seams, I have a loop at the end that runs while time elapsed since the function began is less than that determined precompile, and on each iteration is sleeps for an interval determined by the simulated clock speed of the proc in particular.  I did run into a bump setting random clock speeds, as the simultaneity of the procs meant I was getting the same random clockspeed, and since all the simulation procs have very similar PIDs, these didn't add muchn entropy, so I moved to generating all 3 clock speeds prior to forking off the simulation procs, and then using them at initialization.

	The next challenge was I didn't think ahead about how to get around the fact that pipes block on read if there is nothing in them and the pipe is open, as would happen in the sim, but I found a way to set a NON_BLOCK flag for the pipe fds that should let us determine whether there is a message without blocking.

	The O_NONBLOCK option seems to have worked perfectly.  We ran into a little confusion getting the array of pipes configured and the ordering working as we intended but it all smoothed out.  After the communication was working, on to implimenting the clocks.

	Since we are using pipes for IPC it is immpossible to tell how many messages are queued up in a pipe, so as alternative, since the IPC protocol doesn't have to run at the clockspeed of the VMs, we've decided that on each VM cycle, each proc will read messages from the pipe and store them in a queue to process later.  Then, once the pipe is empty, each cycle will consist of the VM checking if there are messages in the queue.  If so, we'll pop one and process it, updating the logical clock as the spec says.  Otherwise, we'll follow the spec algorithm of choosing another operation, either send or internal event at random and executing it.

	OK, this is all implimented a debugged now.  The logging all seems to be working splendidly, except that the format of the log entries is garbage and makes reading the log horrible.  Time to rethink those.

	Okey dokey, formatting looks semi-reasonable now.  If I watch the log in real-time as the process runs, we get clumping behavior in the output and chunks are written to the log, but I'm 99.9% sure this is because of the caching of fprintf to STDOUT and then on to the log file.  Otherwise, on first analysis, the logs look promising.  It looks like this is the behavior we would expect, but now time to mess around with some parameters, and take a closer analysis to the logs to see how the logical clocks are behaving.

2.) Analysis
	